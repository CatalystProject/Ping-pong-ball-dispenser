#include <Servo.h>
#include <MsTimer2.h>

#define DROP_PERIOD 4
#define DEBUG false

/*
This code is intended to drive the ping pong ball dispenser hardware
created as part of the Catalyst project. There are 3 different modes in 
which the ping pong ball dispenser can release a ball - through button 
interrupt (not used), at a constant rate of n seconds, and at a constant interval, 
but following a 'random' pattern of release (defined in dataPoints array).

When the threshold value has been surpassed, n balls are released from the
dispenser - this is actuated via a Servo attached to pin 3. Due to incompatibility
with the Timer library, MSTimer2 library was used to trigger a timed interrupt.

Author - Catalyst Project (Peter Newman)
*/

//enum used to set drop mode
enum DropMode{
  BUTTON,
  CONST,
  RAND
};

//servo instance
Servo servo1;

//drop 1 ball or more/less randomly
boolean ballDropConst = true;
int dropTime = 0;
int dropCount = 1;
//default drop mode
DropMode dropMode = CONST;

//data points of kWH generated by wind turbine (23rd Dec 2013)
float dataPoints[] = {68.5,145.5,57.5,196.5,417.5,431,450.5,455,463.5,465.5,465.5,465.5,444,456,458.5,360.5,313.5,322,255.5,247.5,152.5,116.5,93.5,116.5,90.5,75,105,100,203.5,289.5,338,444,460.5,465.5,301,450,441.5,464.5,463,464,466,465.5,463.5,464.5,464};
int currentPos = 0;
  
//for debugging - whether to move servo or not when triggered
boolean cycleServo = false;

void initTimer(){  
	//attach timer function handler and start
    MsTimer2::set(1000, timerTick);
    MsTimer2::start();
}

void setup(){
	if (DEBUG)
		Serial.begin(9600);

	//init pin and attach to servo
	pinMode( 3, OUTPUT);
	servo1.attach( 3 );

	//button pin
	pinMode( 2, INPUT_PULLUP);
	
	//pin 12 used as status LED
	pinMode( 12, OUTPUT);
	digitalWrite(12, HIGH);

	//set servo to 0 position
	servo1.write(0);
	delay(2000); 
	
	//read input from pin 2 - (control pin)
	int pinState = digitalRead(2);
	if ( pinState == 1 ){		
		//if pinstate read is 1 (on), start constant release)
		initTimer();   
	}
	else if ( pinState == 0 ){    
		//if pinstate read is 0 (off), start 'random' release)
		ballDropConst = false;   
		initTimer();    
	}
}

void timerTick(){
	//DROP_PERIOD is multiplier for timer - timer for MSTimer relatively granular, so this multiplier extends it to something usable.
	if ( dropTime == DROP_PERIOD){
		//generate random number
		if ( !ballDropConst ){
		  if ( currentPos > sizeof(dataPoints)/sizeof(float) )
			currentPos = 0;
		  
		  //look at current array position and then drop x number of balls
		  float val = dataPoints[currentPos];
		  dropCount = getDropCount( val );     
		  
		  currentPos++;  
		}   
		
		//reset drop time and allow servo to move
		cycleServo = true;
		dropTime = 0;
	}
	else{
		dropTime++;
	} 
}

int getDropCount( float val ){
	//built-in thresholds for ball release to determine number of balls released
	if ( val < 150 )
		return 0;
	else if ( val <= 450 )
		return 1;
	else if ( val > 450 )
		return 2;
	return 0;
}

void buttonPress(){
  //set move condition to true (not currently used)
  cycleServo = true;
}

void loop(){
  //only move servo if cycleServo has been set to true
  if ( cycleServo ){
    //display code to show 
	
	//print debug to Serial of number of balls to drop
	if (DEBUG){
		Serial.print("Dropping:");
		Serial.println(dropCount);  
		Serial.print("To Drop:");

		//output 
		if ( dropMode == RAND ){
			int pos = currentPos;
			if ( pos > sizeof(dataPoints)/sizeof(float) )
				pos = 0;
			
			float val = dataPoints[pos];
			Serial.println( getDropCount( val ));       
		
		}
		else{        
			Serial.println(dropCount);  
		}
	}
	
	//drop number of balls specified in timer interrupt.
    for ( int i = 0; i < dropCount; i++ ){      
      servo1.write(180);
      delay(1000); 
      servo1.write(0);
      delay(1000);   
    }
	//reset cycleServo back to false
    cycleServo = false;
  }
}
